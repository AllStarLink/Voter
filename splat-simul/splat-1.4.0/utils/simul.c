/****************************************************************************
*              SIMUL -  A SPLAT! Simulcast Transmitter Plotting             *
*                      Copyright Jim Dixon, WB6NIL 2013                     *
*                         Last update: 28-Sep-2013                          *
*****************************************************************************
*                                                                           *
* This program reads a .dsf ("dude" simulcast file), generated by splat     *
* (with simulcast/.dsf support), and generates a '.png' graphic file on     *
* the fly, based upon user HTML for data POST-ed to it.
*                                                                           *
*****************************************************************************
*                                                                           *
* This program is free software; you can redistribute it and/or modify it   *
* under the terms of the GNU General Public License as published by the     *
* Free Software Foundation; either version 2 of the License or any later    *
* version.                                                                  *
*                                                                           *
* This program is distributed in the hope that it will useful, but WITHOUT  *
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or     *
* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License     *
* for more details.                                                         *
*                                                                           *
*****************************************************************************
*          To compile: gcc -Wall -O6 -s simul.c -o simul -lgd               *
*****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <gd.h>

#define MAXTX 4
#define NAMELEN 128

#define	USPERMILE 5.37

#define	MAXDB 10
#define	MINUSECS 82.5

char name[MAXTX][NAMELEN];
float lat[MAXTX];
float lon[MAXTX];
int x[MAXTX],y[MAXTX],maxx,maxy,minwest,maxwest,minnorth,maxnorth;

struct txdata {
	int	x;
	int	y;
	float	distus;
	unsigned char signal;
} *txdata[MAXTX];

int cnt[MAXTX],ld[MAXTX],gld = 0;

typedef struct {
    char *name;
    char *val;
} entry;

#define	MAX_ENTRIES 10000

#define LF 10
#define CR 13

static char *makeword(char *line,char stop)
{
    int x = 0,y;
    char *word = (char *) malloc(sizeof(char) * (strlen(line) + 1));

    for(x=0;((line[x]) && (line[x] != stop));x++)
        word[x] = line[x];

    word[x] = '\0';
    if(line[x]) ++x;
    y=0;

    while((line[y++] = line[x++]));
    return word;
}

static char *fmakeword(FILE *f,char stop,int *cl)
{
    int wsize;
    char *word;
    int ll;

    wsize = 102400;
    ll=0;
    word = (char *) malloc(sizeof(char) * (wsize + 1));

    while(1) {
        word[ll] = (char)fgetc(f);
        if(ll==wsize) {
            word[ll+1] = '\0';
            wsize+=102400;
            word = (char *)realloc(word,sizeof(char)*(wsize+1));
        }
        --(*cl);
        if((word[ll] == stop) || (feof(f)) || (!(*cl))) {
            if(word[ll] != stop) ll++;
            word[ll] = '\0';
            return word;
        }
        ++ll;
    }
}

static char x2c(char *what)
{
    register char digit;

    digit = (what[0] >= 'A' ? ((what[0] & 0xdf) - 'A')+10 : (what[0] - '0'));
    digit *= 16;
    digit += (what[1] >= 'A' ? ((what[1] & 0xdf) - 'A')+10 : (what[1] - '0'));
    return(digit);
}

static void unescape_url(char *url)
{
    register int x,y;

    for(x=0,y=0;url[y];++x,++y) {
        if((url[x] = url[y]) == '%') {
            url[x] = x2c(&url[y+1]);
            y+=2;
        }
    }
    url[x] = '\0';
}

static void plustospace(char *str)
{
    register int x;

    for(x=0;str[x];x++) if(str[x] == '+') str[x] = ' ';
}

static void noctrl(unsigned char *str)
{
int	i;

	for(i = 0; str[i]; i++) 
	   {
		if ((str[i] < 32) || (str[i] > 127)) str[i] = ' ';
		if (str[i] == '<') str[i] = '(';
		if (str[i] == '>') str[i] = ')';
		if (str[i] == '\\') str[i] = '/' ;
		if (str[i] == '`') str[i] = '\'';
	   }
	return;
}


int main(int argc, char *argv[])
{

int	i,j,m,n,k,cl,x0,y0,found,ntx = 0,black;
char	str[300],dirname[300],fname[300],*cp;
float	d,f;
FILE	*fp;
struct	txdata *mytx,*tx1,*tx2;
gdImagePtr  image;
entry entries[MAX_ENTRIES];


	if(strcmp(getenv("REQUEST_METHOD"),"POST"))
	{
		printf("Content-type: text/html%c%c",10,10);
	        printf("Internal Error #1\n");
	        exit(1);
	}
	if(strcmp(getenv("CONTENT_TYPE"),"application/x-www-form-urlencoded"))
	{
		printf("Content-type: text/html%c%c",10,10);
	        printf("Internal error #2. \n");
	        exit(1);
	}
	cl = atoi(getenv("CONTENT_LENGTH"));


	m = -1;
	for(i = 0;cl && (!feof(stdin));i++)
	{
	        m = i;
	        entries[i].val = fmakeword(stdin,'&',&cl);
	        plustospace(entries[i].val);
	        unescape_url(entries[i].val);
		noctrl((unsigned char*)entries[i].val);
	        entries[i].name = makeword(entries[i].val,'=');
	}

	ntx = m + 1;

	memset(dirname,0,sizeof(dirname));
	strncpy(dirname,(char *)entries[0].name,sizeof(dirname) - 1);
	cp = strrchr(dirname,'/');
	if (cp) *cp = 0;
	cp = strrchr(dirname,'/');
	if (cp) strcpy(fname,cp + 1);

	printf("Content-type: image/png\n\n");

	gld = 0;
	for(i = 0; i < ntx; i++)
	{
		j = atoi(entries[i].val);
		if (j > gld) gld = j;
	}

	memset(txdata,0,sizeof(txdata));
	for(i = 0; i < ntx; i++)
	{
		sprintf(str,"%s.dsf",entries[i].name);
		j = atoi(entries[i].val);
//		fprintf(stderr,"Processing %s (%d uSec Launch Delay)...",str,j);
		ld[i] = gld - j;
		fflush(stdout);
		fp = fopen(str,"r");
		if (!fp)
		{
			fprintf(stderr,"\nCant open file %s:%s\n",str,strerror(errno));
			exit(255);
		}
		n = 0;
		while(fgets(str,sizeof(str) - 1,fp))
		{
			if (n == 0)
			{
				if (sscanf(str,"%s %f %f %d %d %d %d %d %d %d %d",&name[i][0],
					&lat[i],&lon[i],&x[i],&y[i],&maxx,&maxy,
					&minwest,&maxwest,&minnorth,&maxnorth) < 11)
				{
					fprintf(stderr,"Error parsing header!!\n");
					exit(255);
				}
				txdata[i] = malloc(maxx * maxy * sizeof(struct txdata));
				if (!txdata[i])
				{
					perror("malloc() failed");
					exit(255);
				}
				memset(txdata[i],0,maxx * maxy * sizeof(struct txdata));		
			}
			else
			{
				if (sscanf(str,"%d %d %d %f",&x0,&y0,&k,&f) < 4)
				{
					fprintf(stderr,"Error parsing data!!\n");
					exit(255);
				}
				if ((x0 < 0) || (x0 >= maxx) || (y0 < 0) || (y0 >= maxy))
					continue;
				f *= USPERMILE;
				mytx = txdata[i] + (y0 * maxx) + x0;
				mytx->x = x0;
				mytx->y = y0;
				mytx->signal = k;
				mytx->distus = f;
			}
			n++;
		}
//		fprintf(stderr," %d records.\n",n);
		cnt[i] = n;
		fclose(fp);
	}
	sprintf(str,"%s/%s.png",dirname,fname);
	fp = fopen(str,"r");
	if (!fp)
	{
		perror("Cant open image file!!");
		exit(255);
	}
	image = gdImageCreateFromPng(fp);
	if (!image)
	{
		fprintf(stderr,"Cant open image file in gd!!\n");
		exit(255);
	}
	fclose(fp);
	black = gdImageColorAllocate(image, 0,0,0);
	for(x0 = 0; x0 < maxx; x0++)
	{
		for(y0 = 0; y0 < maxy; y0++)
		{
			found = 0;
			for(i = 0; i < ntx; i++)
			{
				tx1 = txdata[i] + (y0 * maxx) + x0;
				if (!tx1->signal) continue;
				for(j = i + 1; j < ntx; j++)
				{
					tx2 = txdata[j] + (y0 * maxx) + x0;
					if (!tx2->signal) continue;
					if ((tx1->distus - ld[i]) >= (tx2->distus - ld[j]))
						d = (tx1->distus - ld[i]) - (tx2->distus - ld[j]);
					else
						d = (tx2->distus - ld[j]) - (tx1->distus - ld[i]);
					if (tx1->signal >= tx2->signal)
						k = tx1->signal - tx2->signal;
					else
						k = tx2->signal - tx1->signal;
					if ((k <= MAXDB) && (d >= MINUSECS))
					{
						found = 1;
						break;
					}
				}
				if (found) break;
			}
			if (found) gdImageSetPixel(image, x0, y0, black);
		}
	}
	gdImagePng(image, stdout);
	fflush(stdout);
	exit(0);
}

		
